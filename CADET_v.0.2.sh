#!/bin/bash
function Usage()
{
cat <<-ENDOFMESSAGE
#################################################################################
##      CADET - Concatemer by Amplification DEtection Tool v0.2                ##
##                               Baptista, Rodrigo, 2022                       ##
#################################################################################

Usage

$0 [OPTIONS] -R <Reads.fastq> -w <window size> -s <slide size> -p <your_prefix>

Flag description:

    -R  --reads     fasta/fastq file with reads generated by WGA sequencing using ONT (required)
    -w --window    length of desired window sequences in bp (required) (default = 500)
    -s  --slide     length to slide each window over in bp (required) (default = 500)
    -p  --prefix    Prefix name for your output folder (default = "CADET_output")

Options: 
    -h  --help      display this message

ENDOFMESSAGE
    exit 1
}

function Die()
{
    echo "$*"
    exit 1
}


function GetOpts() {
    reads=""
    window="500"
    slide="500"
    prefix="CADET_output"
    
   # argv=()
    while [ $# -gt 0 ]
    do
        opt=$1
        shift
        case ${opt} in
            -R|--reads)
                arg_has_reads=1
                if [ $# -eq 0 -o "${1:0:1}" = "-" ]; then
                    Die "The ${opt} option requires an argument."
                fi
                reads="$1"
                shift
                ;;
           -w|--window)
                arg_has_window=1
                if [ $# -eq 0 -o "${1:0:1}" = "-" ]; then
                    Die "The ${opt} option requires an argument."
                fi
                window="$1"
                shift
                ;;
           -s|--slide)
                arg_has_slide=1
                if [ $# -eq 0 -o "${1:0:1}" = "-" ]; then
                    Die "The ${opt} option requires an argument."
                fi
                slide="$1"
                shift
                ;;
           -p|--prefix)
                arg_has_prefix=1
                if [ $# -eq 0 -o "${1:0:1}" = "-" ]; then
                        Die "The ${opt} option requires an argument."
                fi
                prefix="$1"
                shift
                ;;
            -h|--help)
                Usage;;
            *)
                if [ "${opt:0:1}" = "-" ]; then
                    Die "${opt}: unknown option."
                fi
 #               argv+=(${opt});;
        esac
    done 


        if [ $arg_has_reads -ne 0 ]; then
                GENOME=${reads}
       else
             echo "Error: -R (reads.fastq) absent"
                Usage
        fi
        if [ -n $arg_has_window ]; then
                W=$window
      else
            echo "Error: window size absent"
                Usage
        fi
        if [ -n $arg_has_slide ]; then
                S=$slide
      else
            echo "Error: slide size absent"
                Usage
        fi
        if [ -n $arg_has_prefix ]; then
                SAMPLE=$prefix
        else
                echo "Error: prefix file absent"
                Usage
   
    exit 1
  fi
}

GetOpts $*

echo "Read file used: $GENOME"
echo "Window size used: $W"
echo "Slide size used: $S"
echo "Prefix used: $SAMPLE"
dict="${GENOME%.*}"

########################
#inFasta=$(seqtk seq -A ${reads})
#chmod 777 input.fasta
#test=$(input.fasta)
#inFasta="$(./input.fasta)"

#usage="Usage: $0 <fasta> <window size> <slide size>"
#nseq=$(grep -c ">" input.fasta)
#nseq=$(cat ${reads}|wc -l)/4|bc

#echo "test"$nseq2
#if [ -z "$3" ]
#then
#  echo $usage
#  exit
#fi
seqtk seq -A $GENOME > input.fa
cat input.fa| grep -c ">" > nseq.txt
#echo $(cat $GENOME|wc -l)/4|bc > nseq.txt
fasta="input.fa"
inFasta=$fasta
inW=$W
inS=$S
n=$(<nseq.txt)
$n=$nseq
#n=$4
## Remove result file if already exists
final_name=$(paste -d '_' \
              <(echo 'windows') \
              <(basename $inFasta))
rm -f $final_name

## Separate sequences in fasta file
echo "> Splitting fasta sequences"
mkdir -p ./fasta_indiv

### Remove alignment formating within sequences
awk '!(NR%2) {gsub("-","")}{print}' $inFasta > ./fasta_indiv/inFasta_format.fasta

### Separate
awk '/^>/{close(s); s="fasta_indiv/"++d".fa"} {print > s}' < ./fasta_indiv/inFasta_format.fasta

## Make sliding windows
mkdir -p $SAMPLE

for indiv_f in fasta_indiv/*.fa ;
do
  # Get sequence name
  seqName=$(awk 'NR==1; ORS=""; OFS=""' $indiv_f | sed 'y/>/ /')
  echo ">" $seqName
  
  # Create result file name
  filename=$(paste -d '_' \
              <(echo "$SAMPLE/windows") \
              <(basename $indiv_f))
              
  # Calculate number of windows
  ## Total characters in sequence
  length=$(awk 'FNR == 2' $indiv_f | wc -m)
  ## Calcuate total complete windows
  total=$((($length-$inW)/$inS))

  ## Exit with error if sequence does not create at least 2 windows
  if (( $total < 2 ));
  then
      echo ">>> Sequence is too short to create windows of desired size and slide. Sequence will be skipped."
      echo $seqName", too short!" >> $SAMPLE/short.txt
      cat $SAMPLE/short.txt | wc -l| awk '{print "Short sequences:\t"$0}' >> $SAMPLE/stats.txt
      continue
  else
      echo ">>> Creating" $total "windows"
  fi
  
  # Create windows
  for i in `seq 1 $total`;
  do
    # Define start and end of window
    start=$((1 + ($i-1)*$inS))
    end=$(($start + $inW -1))

    # Create window name
    nameW=$(paste -d '_' \
              <(echo ">$i") \
              <(echo $seqName) \
              <(echo 'window') \
              <(echo $start) \
              <(echo $end))
            
    echo $nameW >> $filename
    
    # Get window sequence
    awk 'FNR == 2' $indiv_f | \
      awk -v start="$start" -v w="$inW" '{ print substr($1, start, w) }' \
      >> $filename
    
  done
         
done

## Run Minimap2 for overlaps
for (( j = 1; j <= $n; j++ ))
  do
#  minimap2 -x ava-ont -a '$SAMPLE/'windows_$j.fa '$SAMPLE/'windows_$j.fa > '$SAMPLE/'windows_$j.sam  
nucmer --maxmatch --coords -p $SAMPLE/window_$j $SAMPLE/windows_$j.fa $SAMPLE/windows_$j.fa --nosimplify
more $SAMPLE/window_$j.coords| sed 's/|/\t/g' |grep -v "NUCMER\|TAGS\|=="|cut -f5,6| awk '{if ($1 != $2) print $0}' > $SAMPLE/window_$j.concat
more $SAMPLE/window_$j.coords| sed 's/|/\t/g' |grep -v "NUCMER\|TAGS\|=="|cut -f5,6| awk '{if ($1 != $2) print $0}'|awk -F'\t' 'NR>0{$0=$0"\t"NR-1} 1'| sed 's/_/\t/g'| cut -f2| sort| uniq| awk -v var=$j '{print "window_"var"\t"$0}' >> window_read_ID.txt
more $SAMPLE/window_$j.coords| sed 's/|/\t/g' |grep -v "NUCMER\|TAGS\|=="|cut -f5,6| awk '{if ($1 != $2) print $0}'| wc -l| sed 's/ //g' >> $SAMPLE/concat_count.tab
#cd $SAMPLE
#ls | grep '\.coords$' | sed 's/_/\t/g'| sed 's/\./\t/g'| sort -k2 -n | sed 's/ow\t/ow_/g'| sed 's/\tcoords/.coords/g' > concat_IDs.txt
#if concat=0 print no concatemer detected
done

## Combine results
#echo "> Combining window results"
#cat $SAMPLE/*.fa >> $final_name
more $SAMPLE/concat_count.tab | awk -F'\t' 'NR>0{$0=$0"\t"NR-1} 1'| awk '{print "window_"$2+1"\t"$1/2}'| awk '{if ($2 != 0) print $0}' > Concat_Final.tab

more $SAMPLE/concat_count.tab | awk -F'\t' 'NR>0{$0=$0"\t"NR-1} 1'| awk '{print "window_"$2+1"\t"$1}'| awk '{if ($2 ==0) print $2}'| wc -l| awk '{print "Number of non-concatemer detected: "$0}' >> $SAMPLE/stats.txt 
more $SAMPLE/concat_count.tab | awk -F'\t' 'NR>0{$0=$0"\t"NR-1} 1'| awk '{print "window_"$2+1"\t"$1}'| awk '{if ($2 !=0) print $2}'| wc -l| awk '{print "Number of putative concatemer detected: "$0}' >> $SAMPLE/stats.txt
grep -c ">" input.fa | awk '{print "Total number of Reads:\t"$0"\n### putative concatemers ###\nread_number\tread_ID\tself_alignemts"}' >> $SAMPLE/stats.txt
join window_read_ID.txt Concat_Final.tab >> $SAMPLE/stats.txt
join window_read_ID.txt Concat_Final.tab | sed 's/ /\t/g'| cut -f 2 > $SAMPLE/concat_IDs
seqtk subseq $GENOME $SAMPLE/concat_IDs > $SAMPLE/Concat.fastq
## Remove intermediate files
rm Concat_Final.tab
rm window_read_ID.txt
rm -R fasta_indiv
rm nucmer.error
rm $SAMPLE/*.delta
rm $SAMPLE/window*.concat
rm $SAMPLE/windows*.fa
rm input.fa
rm nseq.txt
#rm -R $SAMPLE
#echo "ls | grep -c '\.coords$'"
#echo ""
mkdir $SAMPLE/coords
mv $SAMPLE/*.coords $SAMPLE/coords/
echo "> FINISHED!"
echo "Thank you for Running CADET"
